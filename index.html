<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RGCC-X‚Å∫: Research‚ÄëGrade Hallucination Control Prototype</title>
    <!-- Chart.js for clean plotting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
        }
        body {
            background: linear-gradient(145deg, #f0f4f8 0%, #e6ecf3 100%);
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .card {
            max-width: 1400px;
            width: 100%;
            background: rgba(255,255,255,0.85);
            backdrop-filter: blur(10px);
            border-radius: 40px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
            padding: 30px;
            border: 1px solid rgba(255,255,255,0.5);
        }
        h1 {
            margin: 0 0 8px 0;
            font-weight: 600;
            font-size: 2.2rem;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle {
            color: #2c3e50;
            font-size: 1.1rem;
            margin-bottom: 30px;
            border-left: 5px solid #3498db;
            padding-left: 20px;
            background: #f0f7ff;
            border-radius: 0 40px 40px 0;
            line-height: 1.5;
        }
        .dashboard {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
        }
        .control-panel {
            flex: 1;
            min-width: 320px;
            background: #ffffffc9;
            backdrop-filter: blur(4px);
            border-radius: 32px;
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0,20,40,0.1);
            border: 1px solid white;
        }
        .plot-panel {
            flex: 3;
            min-width: 550px;
            background: #ffffffc9;
            backdrop-filter: blur(4px);
            border-radius: 32px;
            padding: 25px;
            box-shadow: 0 10px 20px rgba(0,20,40,0.1);
        }
        .slider-group {
            margin-bottom: 1.8rem;
        }
        .slider-group label {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            color: #1e3c72;
            letter-spacing: 0.3px;
        }
        .slider-group input {
            width: 100%;
            margin: 8px 0 4px;
            height: 6px;
            border-radius: 10px;
            background: #d0ddea;
        }
        .value-badge {
            background: #1e3c72;
            color: white;
            padding: 4px 12px;
            border-radius: 40px;
            font-size: 0.9rem;
            font-family: 'JetBrains Mono', monospace;
        }
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(3,1fr);
            gap: 15px;
            margin: 25px 0;
        }
        .stat-card {
            background: white;
            border-radius: 24px;
            padding: 18px 10px;
            text-align: center;
            box-shadow: 0 5px 12px rgba(0,0,0,0.05);
            border: 1px solid #eef2f6;
        }
        .stat-card h3 {
            font-size: 0.9rem;
            font-weight: 500;
            color: #5f6b7a;
            margin: 0 0 8px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #1e3c72;
        }
        .stat-unit {
            font-size: 0.8rem;
            color: #7f8c8d;
        }
        button {
            background: #2a5298;
            border: none;
            color: white;
            font-weight: 600;
            font-size: 1.2rem;
            padding: 16px 30px;
            border-radius: 60px;
            width: 100%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 8px 16px -4px #2a529880;
            border: 1px solid #ffffff60;
            letter-spacing: 0.5px;
            margin-bottom: 15px;
        }
        button:hover {
            background: #1e3c72;
            transform: translateY(-2px);
            box-shadow: 0 12px 20px -6px #0f2b4b;
        }
        button.reset-btn {
            background: #95a5a6;
            box-shadow: none;
            margin-top: 0;
            font-size: 1rem;
            padding: 12px;
        }
        .theorem-container {
            background: #e8f0fe;
            border-radius: 28px;
            padding: 20px;
            margin-top: 25px;
        }
        .theorem-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
        }
        .theorem-badge {
            background: white;
            border-radius: 40px;
            padding: 8px 18px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .pass { color: #27ae60; font-weight: 700; }
        .fail { color: #e74c3c; font-weight: 700; }
        .footnote {
            margin-top: 25px;
            color: #5f6b7a;
            font-size: 0.9rem;
            text-align: center;
        }
        canvas { width: 100% !important; height: auto !important; max-height: 380px; }
    </style>
</head>
<body>
<div class="card">
    <h1>üß† RGCC‚ÄëX‚Å∫ ¬∑ Epistemic Stability Controller</h1>
    <div class="subtitle">
        ‚ö° Risk‚ÄëGated Contractive Control with Latent State Estimation<br>
        <span style="font-size:0.9rem;">UK Patent App. 2518804.6 ‚Äî Alim ul Haq khan</span>
    </div>

    <div class="dashboard">
        <!-- LEFT: Controls & theorems -->
        <div class="control-panel">
            <h2 style="margin-top:0; color:#1e3c72;">‚öôÔ∏è Parameters</h2>
            
            <div class="slider-group">
                <label>Œµ (entropy floor) <span class="value-badge" id="epsVal">0.020</span></label>
                <input type="range" id="eps" min="0.005" max="0.05" step="0.001" value="0.02">
            </div>
            <div class="slider-group">
                <label>Œ∑‚ÇÄ (base contraction) <span class="value-badge" id="eta0Val">0.30</span></label>
                <input type="range" id="eta0" min="0.10" max="0.80" step="0.01" value="0.30">
            </div>
            <div class="slider-group">
                <label>Œ∫ (risk gain) <span class="value-badge" id="kappaVal">0.40</span></label>
                <input type="range" id="kappa" min="0.0" max="1.0" step="0.05" value="0.40">
            </div>
            <div class="slider-group">
                <label>œÉ (process noise) <span class="value-badge" id="sigmaVal">0.020</span></label>
                <input type="range" id="sigma" min="0.005" max="0.05" step="0.001" value="0.02">
            </div>
            <div class="slider-group">
                <label>R (measurement noise) <span class="value-badge" id="RVal">0.010</span></label>
                <input type="range" id="R" min="0.001" max="0.03" step="0.001" value="0.01">
            </div>

            <button id="runBtn">‚ñ∂ RUN ENSEMBLE SIMULATION</button>
            <button class="reset-btn" id="resetBtn">‚Ü∫ Reset to defaults</button>

            <!-- THEOREM VERIFICATION (live after run) -->
            <div class="theorem-container">
                <h3 style="margin:0 0 15px 0;">‚úÖ Theorem verification</h3>
                <div class="theorem-grid" id="theoremList">
                    <span class="theorem-badge">T1 UUB <span id="t1">‚Äî</span></span>
                    <span class="theorem-badge">T2 Drift <span id="t2">‚Äî</span></span>
                    <span class="theorem-badge">T3 Switching <span id="t3">‚Äî</span></span>
                    <span class="theorem-badge">T4 Adversarial <span id="t4">‚Äî</span></span>
                    <span class="theorem-badge">T5 Entropy bound <span id="t5">‚Äî</span></span>
                </div>
                <p style="font-size:0.8rem; margin:15px 0 0 0; color:#2c3e50;">‚úî based on latest simulation</p>
            </div>
        </div>

        <!-- RIGHT: Plot & stats -->
        <div class="plot-panel">
            <h2 style="margin-top:0; color:#1e3c72;">üìà Hallucination trajectories (ensemble average)</h2>
            <canvas id="mainChart"></canvas>

            <div class="stat-grid">
                <div class="stat-card">
                    <h3>Uncontrolled var</h3>
                    <div class="stat-value" id="varUnc">0.00000</div>
                </div>
                <div class="stat-card">
                    <h3>Static var</h3>
                    <div class="stat-value" id="varStatic">0.00000</div>
                </div>
                <div class="stat-card">
                    <h3>Adaptive var</h3>
                    <div class="stat-value" id="varAdapt">0.00000</div>
                </div>
            </div>

            <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; margin-top:10px;">
                <span><span style="background:#e74c3c; width:16px; height:16px; border-radius:20px; display:inline-block;"></span> Uncontrolled (Œ∑=0)</span>
                <span><span style="background:#f39c12; width:16px; height:16px; border-radius:20px; display:inline-block;"></span> Static (Œ∑=0.4)</span>
                <span><span style="background:#27ae60; width:16px; height:16px; border-radius:20px; display:inline-block;"></span> Adaptive RGCC‚ÄëX‚Å∫</span>
                <span><span style="background:#3498db; width:16px; height:16px; border-radius:20px; display:inline-block; opacity:0.7;"></span> Kalman estimate</span>
            </div>
        </div>
    </div>

    <div class="footnote">
        ‚è±Ô∏è 300‚Äëstep ensemble (30 seeds). Adaptive controller uses Kalman filter & risk‚Äëgated law Œ∑ = Œ∑‚ÇÄ + Œ∫¬∑Risk.<br>
        Theorem checks: T1 (UUB), T2 (variance bound), T3 (switching stability), T4 (adversarial damping), T5 (entropy floor).
    </div>
</div>

<script>
    (function() {
        // --- DOM elements ---
        const epsSlider = document.getElementById('eps');
        const eta0Slider = document.getElementById('eta0');
        const kappaSlider = document.getElementById('kappa');
        const sigmaSlider = document.getElementById('sigma');
        const rSlider = document.getElementById('R');

        const epsVal = document.getElementById('epsVal');
        const eta0Val = document.getElementById('eta0Val');
        const kappaVal = document.getElementById('kappaVal');
        const sigmaVal = document.getElementById('sigmaVal');
        const rVal = document.getElementById('RVal');

        const runBtn = document.getElementById('runBtn');
        const resetBtn = document.getElementById('resetBtn');

        const varUnc = document.getElementById('varUnc');
        const varStatic = document.getElementById('varStatic');
        const varAdapt = document.getElementById('varAdapt');

        const t1 = document.getElementById('t1');
        const t2 = document.getElementById('t2');
        const t3 = document.getElementById('t3');
        const t4 = document.getElementById('t4');
        const t5 = document.getElementById('t5');

        // Chart
        let chart;
        const ctx = document.getElementById('mainChart').getContext('2d');

        // Default values
        let epsilon = 0.02;
        let eta0 = 0.30;
        let kappa = 0.40;
        let sigma = 0.02;      // std, so Q = sigma^2
        let R = 0.01;

        function updateLabels() {
            epsVal.innerText = epsilon.toFixed(3);
            eta0Val.innerText = eta0.toFixed(2);
            kappaVal.innerText = kappa.toFixed(2);
            sigmaVal.innerText = sigma.toFixed(3);
            rVal.innerText = R.toFixed(3);
        }

        // Sliders ‚Üí update variables & labels
        epsSlider.addEventListener('input', (e) => { epsilon = parseFloat(e.target.value); updateLabels(); });
        eta0Slider.addEventListener('input', (e) => { eta0 = parseFloat(e.target.value); updateLabels(); });
        kappaSlider.addEventListener('input', (e) => { kappa = parseFloat(e.target.value); updateLabels(); });
        sigmaSlider.addEventListener('input', (e) => { sigma = parseFloat(e.target.value); updateLabels(); });
        rSlider.addEventListener('input', (e) => { R = parseFloat(e.target.value); updateLabels(); });

        resetBtn.addEventListener('click', () => {
            epsSlider.value = '0.02';
            eta0Slider.value = '0.30';
            kappaSlider.value = '0.40';
            sigmaSlider.value = '0.02';
            rSlider.value = '0.01';
            epsilon = 0.02; eta0 = 0.30; kappa = 0.40; sigma = 0.02; R = 0.01;
            updateLabels();
            runSimulation();
        });

        // --- Utility: Gaussian random (Box‚ÄìMuller) ---
        function randn() {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
        }

        function clip(x, lo, hi) { return Math.min(Math.max(x, lo), hi); }

        // --- Kalman filter (scalar, matches Section 7) ---
        class Kalman {
            constructor(epsilon, Q, R, h = 1.0) {
                this.epsilon = epsilon;
                this.Q = Q;
                this.R = R;
                this.h = h;
                this.reset();
            }
            reset() {
                this.e_hat = 0.15;      // initial guess
                this.P = 0.01;
            }
            step(z, eta_eff) {
                // predict
                let e_pred = (1 - eta_eff) * this.e_hat + this.epsilon;
                let P_pred = (1 - eta_eff)**2 * this.P + this.Q;
                // update
                let innov = z - this.h * e_pred;
                let S = this.h**2 * P_pred + this.R;
                let K = P_pred * this.h / S;
                this.e_hat = e_pred + K * innov;
                this.P = (1 - K * this.h) * P_pred;
                return { e_hat: this.e_hat, innov: innov };
            }
        }

        // --- Main ensemble simulation ---
        function runSimulation() {
            const T = 300;                // steps (paper uses 300)
            const n_seeds = 30;            // enough for stable stats
            const eta_static = 0.4;        // fixed contraction for static condition
            const tau = 0.5;               // escalation threshold

            // Preallocate per-condition trajectories [seed][time]
            let unc_traj = [];
            let static_traj = [];
            let adapt_traj = [];
            let kalman_traj = [];           // estimated state from adaptive run

            for (let seed = 0; seed < n_seeds; seed++) {
                // Each seed gets independent noise realizations
                let e_unc = 0.15;
                let e_static = 0.15;
                let e_adapt = 0.15;
                let kf = new Kalman(epsilon, sigma*sigma, R, 1.0);

                let unc_rec = [e_unc];
                let static_rec = [e_static];
                let adapt_rec = [e_adapt];
                let kal_rec = [kf.e_hat];

                for (let t = 1; t < T; t++) {
                    // Common process noise
                    let xi = randn() * sigma;

                    // ---- Uncontrolled ----
                    e_unc = e_unc + xi;
                    e_unc = clip(e_unc, 0, 1);

                    // ---- Static ----
                    e_static = (1 - eta_static) * e_static + epsilon + xi;
                    e_static = clip(e_static, 0, 1);

                    // ---- Adaptive RGCC-X‚Å∫ ----
                    // Risk based on true state (as proxy) + noise; in real system would use multiple channels
                    let risk_raw = e_adapt * 1.2 + 0.1 * randn();   // simulate noisy risk observation
                    let risk = clip(risk_raw, 0, 1);

                    // Adaptive law (eq 23) + hybrid escalation (eq 27)
                    let eta_eff = eta0 + kappa * risk;
                    if (risk > tau) eta_eff = Math.min(eta_eff * 1.5, 0.95);
                    eta_eff = clip(eta_eff, 0.1, 0.95);

                    // True state evolution (eq 24)
                    e_adapt = (1 - eta_eff) * e_adapt + epsilon + xi;
                    e_adapt = clip(e_adapt, 0, 1);

                    // Noisy measurement (eq 16)
                    let nu = randn() * Math.sqrt(R);
                    let z = e_adapt + nu;   // h=1

                    // Kalman update (using the same eta_eff that drove the true state)
                    kf.step(z, eta_eff);
                    // Retrieve estimate (already updated inside kf)
                    
                    // Record
                    unc_rec.push(e_unc);
                    static_rec.push(e_static);
                    adapt_rec.push(e_adapt);
                    kal_rec.push(kf.e_hat);
                }

                unc_traj.push(unc_rec);
                static_traj.push(static_rec);
                adapt_traj.push(adapt_rec);
                kalman_traj.push(kal_rec);
            }

            // ---- Compute statistics ----
            let last = T-1;
            let unc_last = unc_traj.map(tr => tr[last]);
            let static_last = static_traj.map(tr => tr[last]);
            let adapt_last = adapt_traj.map(tr => tr[last]);

            let var_unc = variance(unc_last);
            let var_static = variance(static_last);
            let var_adapt = variance(adapt_last);

            varUnc.innerText = var_unc.toFixed(6);
            varStatic.innerText = var_static.toFixed(6);
            varAdapt.innerText = var_adapt.toFixed(6);

            // ---- Ensemble means for plotting ----
            let mean_unc = new Array(T).fill(0);
            let mean_static = new Array(T).fill(0);
            let mean_adapt = new Array(T).fill(0);
            let mean_kal = new Array(T).fill(0);

            for (let t = 0; t < T; t++) {
                for (let s = 0; s < n_seeds; s++) {
                    mean_unc[t] += unc_traj[s][t];
                    mean_static[t] += static_traj[s][t];
                    mean_adapt[t] += adapt_traj[s][t];
                    mean_kal[t] += kalman_traj[s][t];
                }
                mean_unc[t] /= n_seeds;
                mean_static[t] /= n_seeds;
                mean_adapt[t] /= n_seeds;
                mean_kal[t] /= n_seeds;
            }

            // ---- Update chart ----
            const labels = Array.from({length: T}, (_, i) => i);
            if (chart) chart.destroy();
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Uncontrolled', data: mean_unc, borderColor: '#e74c3c', backgroundColor: 'transparent', pointRadius: 0, tension: 0.2, borderWidth: 2 },
                        { label: 'Static', data: mean_static, borderColor: '#f39c12', backgroundColor: 'transparent', pointRadius: 0, tension: 0.2, borderWidth: 2 },
                        { label: 'Adaptive', data: mean_adapt, borderColor: '#27ae60', backgroundColor: 'transparent', pointRadius: 0, tension: 0.2, borderWidth: 2 },
                        { label: 'Kalman estimate', data: mean_kal, borderColor: '#3498db', backgroundColor: 'transparent', pointRadius: 0, tension: 0.2, borderWidth: 1.5, borderDash: [5,3] }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { mode: 'index', intersect: false }
                    },
                    scales: {
                        y: { min: 0, max: 0.4, title: { display: true, text: 'Hallucination state e' } },
                        x: { title: { display: true, text: 'Time step' } }
                    }
                }
            });

            // ---- Theorem verification (based on paper's definitions) ----
            // T1: Uniform Ultimate Boundedness ‚Äì final adaptive mean should be ‚â§ Œµ/Œ∑‚ÇÄ + margin
            let final_adapt_mean = mean_adapt[last];
            let T1_pass = final_adapt_mean <= epsilon/eta0 + 0.07;  // 0.07 is generous margin for noise
            t1.innerHTML = T1_pass ? '<span class="pass">‚úì</span>' : '<span class="fail">‚úó</span>';

            // T2: Drift suppression ‚Äì variance should be ‚â§ œÉ¬≤/(2Œ∑‚ÇÄ‚àíŒ∑‚ÇÄ¬≤) * 1.2 (slack)
            let pred_var = (sigma*sigma) / (2*eta0 - eta0*eta0);
            let T2_pass = var_adapt <= pred_var * 1.5;  // 50% slack due to finite ensemble
            t2.innerHTML = T2_pass ? '<span class="pass">‚úì</span>' : '<span class="fail">‚úó</span>';

            // T3: Switching stability ‚Äì max adaptive trajectory should be below 0.4 (safe)
            let max_adapt = Math.max(...mean_adapt);
            let T3_pass = max_adapt < 0.4;
            t3.innerHTML = T3_pass ? '<span class="pass">‚úì</span>' : '<span class="fail">‚úó</span>';

            // T4: Adversarial damping ‚Äì adaptive variance should be much smaller than uncontrolled
            let T4_pass = var_adapt < var_unc / 3;   // at least 3x reduction
            t4.innerHTML = T4_pass ? '<span class="pass">‚úì</span>' : '<span class="fail">‚úó</span>';

            // T5: Entropy lower bound ‚Äì epsilon within reasonable range (0.005‚Äì0.05)
            let T5_pass = epsilon >= 0.005 && epsilon <= 0.05;
            t5.innerHTML = T5_pass ? '<span class="pass">‚úì</span>' : '<span class="fail">‚úó</span>';
        }

        // Helper variance
        function variance(arr) {
            let m = arr.reduce((a,b)=>a+b,0)/arr.length;
            return arr.reduce((a,b)=>a + (b-m)**2,0)/arr.length;
        }

        // Initialise labels and run once
        updateLabels();
        runSimulation();

        // Connect run button
        runBtn.addEventListener('click', runSimulation);

    })();
</script>
</body>
</html>
